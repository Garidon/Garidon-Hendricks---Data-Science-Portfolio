---
title: "Baby Name Popularity (Controlled for Boomers)"
subtitle: "Personal Project #1"
author: "Garidon Hendricks"
format:
  html:
    self-contained: true
    page-layout: full
    title-block-banner: true
    toc: true
    toc-depth: 3
    toc-location: body
    number-sections: false
    html-math-method: katex
    code-fold: true
    code-summary: "Expand"
    code-overflow: wrap
    code-copy: hover
    code-tools:
        source: false
        toggle: true
        caption: See code
execute: 
  warning: false
    
---

```{python}
import pandas as pd
import numpy as np
from lets_plot import *
from IPython.display import display, Markdown

LetsPlot.setup_html(isolated_frame=True)
```

You can download this qmd file and the associated data here: https://github.com/byui-math-dept/garidon_fall2025_2/tree/main/Personal_Projects/Baby%20Names

In class, we graphed a name's popularity over time based on absolute numbers of children given that name that year. But there are larger trends at play here, such as a 60% increase in the general population following World War II. Did the name Mary become drastically more popular in the boomer era? Or was there simply such a large uptick in population that it _appears_ to reflect a change in parents' naming preferences? We can answer this with the percentage of babies who receive a certain name.

The Social Security Administration helpfully makes free reports available on how many children are named what each year. After compiling those into a csv, I created a gendered_year_total column to use in our percentage calculation. This is a more accurate representation of the likelihood of parents picking a given name than comparing it to the whole population, though as we'll see later, there are some who go against the grain when it comes to gendered naming patterns.

```{python}
babynames = pd.read_csv(r'C:\Users\garid\Documents\GitHub\garidon_fall2025_2\Personal_Projects\Baby Names\all_names.csv')

babynames['gendered_year_total'] = babynames.groupby(['year','sex'])['count'].transform('sum')

babynames["percentage"] = (babynames["count"]/babynames["gendered_year_total"]*100).round(3)
```

With that done, we can select our name of choice (in this case Mary) and graph its use among the two sexes over time. It's fascinating to see that although they're far from plentiful, nearly each year has a non-zero number of males being named Mary. 

```{python}
#Change the name in quotations to display a graph of its use over time
name_select = ("carla").capitalize()

graph_data = babynames.query("name == @name_select")

graph = (ggplot
  (graph_data,aes(x="year",y="percentage",color='sex'))
  +geom_line()
  +labs(x='Year',y="Percentage (By Sex)")
  +scale_color_discrete(name='Sex')
)
graph
```

Now, let's see about generating a chart that shows which names were most popular for each sex in a given year. We'll start by filtering only the rows where the year matches, then separate it by sex, sort by greatest percentage, remove unnecessary data, and change the names of the columns for clarity. After performing that sequence for each sex, we'll combine the results into one readable table.

```{python}
#Change the year specified to update the chart
year = 2000

year_rank = babynames.query("year == @year")

males_rank = (year_rank
  .query("sex == 'M'")
  .sort_values('percentage',ascending=False)
  .drop(columns=['sex','count','year','gendered_year_total'])
  .reset_index(drop=True)
  .rename(columns={'name':'Male Names','percentage':'Percentage'})
)

females_rank = (year_rank
  .query("sex == 'F'")
  .sort_values('percentage',ascending=False)
  .drop(columns=['sex','count','year','gendered_year_total'])
  .reset_index(drop=True)
  .rename(columns={'name':'Female Names','percentage':'Percentage'})
)

combined = pd.concat([males_rank, females_rank], axis=1)
combined.head(10).style.hide(axis="index")

```

Now that we've seen the top ten, I wonder if we can't find the rank of _any_ name for a specified year and sex. 

To do this, we'll make a copy of our babynames data frame, then first filter it by year and sex. We then need to reset the index before we can create a new column that derives the rank from it. With that done, we remove extraneous data and return only the row that matches the specified name.  

```{python}
#Change the year, name, and sex to update the results
year = 2003
print(f'For year: {year}')
name_select = 'Madison'
sex_select = 'F'

rank_display = babynames.copy().sort_values('percentage',ascending=False)
rank_display = (rank_display
  .query("year == @year & sex == @sex_select")
  .reset_index(drop=True)
)

rank_display = (rank_display
  .assign(rank = rank_display.index+1)
  [['name','rank','count','percentage']]
  .query("name == @name_select")
)
rank_display.style.hide(axis="index")
```
